# 11. 经验套路

## 11.1 缓存更新的套路

  - Cache Aside Pattern

    这是最常用最常用的pattern了。其具体逻辑如下：
    - 失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。
    - 命中：应用程序从cache中取数据，取到后返回。
    - 更新：先把数据存到数据库中，成功后，再让缓存失效。

    
      <table>
        <tr>
          <td align="center" style="width: 800px;">
            <img src="https://coolshell.cn/wp-content/uploads/2016/07/Cache-Aside-Design-Pattern-Flow-Diagram-e1470471723210.png" style="width: 1142px;">
            <img src="https://coolshell.cn/wp-content/uploads/2016/07/Updating-Data-using-the-Cache-Aside-Pattern-Flow-Diagram-1-e1470471761402.png" style="width: 1142px;">
          </td>
        </tr>
      </table>

      注意，我们的更新是先更新数据库，成功后，让缓存失效。那么，这种方式是否可以没有文章前面提到过的那个问题呢？我们可以脑补一下。
      一个是查询操作，一个是更新操作的并发，首先，没有了删除cache数据的操作了，而是先更新了数据库中的数据，此时，缓存依然有效，所以，并发的查询操作拿的是没有更新的数据，但是，更新操作马上让缓存的失效了，后续的查询操作再把数据从数据库中拉出来。


## 11.2 XY问题

对于X-Y Problem的意思如下：

1）有人想解决问题X<br>
2）他觉得Y可能是解决X问题的方法<br>
3）但是他不知道Y应该怎么做<br>
4）于是他去问别人Y应该怎么做？

简而言之，没有去问怎么解决问题X，而是去问解决方案Y应该怎么去实现和操作。于是乎：

1）热心的人们帮助并告诉这个人Y应该怎么搞，但是大家都觉得Y这个方案有点怪异。<br>
2）在经过大量地讨论和浪费了大量的时间后，热心的人终于明白了原始的问题X是怎么一回事。<br>
3）于是大家都发现，Y根本就不是用来解决X的合适的方案。

X-Y Problem最大的严重的问题就是：在一个根本错误的方向上浪费他人大量的时间和精力！

## 11.3 如何问问题

  - 提问前先自己尝试查找答案，读读文档、手册，看看有没有相似的问题，看看那些方法能不能帮你解决问题，自己去试一试。如果你是程序员，你应该先学会自己调查一下源代码。（不然，人家回答你的一定是——RTFM – Read The Fucking Manual）这样的问题很多。我有时候很不愿意回答这样的问题，因为我觉得问问题的人把我当成了他的小跟班了。

  - 提问的时候，找正确的人或是正确的论坛发问。向陌生人或是不负责的人提问可能会是很危险的。不正确的人，会让你事倍功半。如果你问Linux的人Windows太慢怎么办？他们一定会让你把Windows删了装Linux去的。

  - 问的问题一定要是很明确的，并且阐述你做了哪些尝试，你一定要简化你的问题，这样可以让你的问题更容易被回答。对于一些问题，最好提供最小化的重现问题的步骤。
  
  - 你一定要让问题变得简单易读，这和写代码是一样的。只有简单易读的邮件，人们才会去读，试想看到一封巨大无比的邮件，读邮件的心情都没有了。而且，内容越多，可能越容易让人理解错了。

  - 你问问题的态度应该是以一种讨论的态度，即不是低三下四，也不是没有底气。只有这样，你和你的问题才能真正被人看得起。要达到这个状态，不想让别人看不起你，你就一定需要自己去做好充足的调查。问题 问得好的话，其实会让人觉得你很有经验的，能想到别人想不到的地方。

  - 不要过早下结论。比如：“我这边的程序不转了，我觉得是你那边的问题，你什么时候能fix？”，或是“太难调试了，gdb怎么这么烂？！”。当你这么做的时候，你一定要有足够的信息和证据，否则，你就显得很自大。好的问题应该是，“我和你的接口的程序有问题，我输入了这样的合法的参数，但是XX函数却总是返回失败，我们能一起看看吗？”，“我看了一下gdb的文档，发现我在用XXX命令调试YYY的时候，有这样ZZZ的问题，是不是我哪里做错了？”

## 11.4 单元测试

  - 一个死的单元测试

    ```C#
      public class Calculator
      {
          public int Add(int x, int y)
          {
              return x + y;
          }
      }

      class Program
      {
          static void Main(string[] args)
          {
              var calculator = new Calculator();

              int result = calculator.Add(5, 6);

              if (result != 11)
                  throw new InvalidOperationException();
          }
      }
    ```
  
  - 好的单元测试（用测试框架）

    ```C#
      [TestClass]
      public class UnitTest1
      {
          [TestMethod]
          public void TestMethod1()
          {
              var calculator = new Calculator();

              int result = calculator.Add(4, 3);

              Assert.AreEqual(7, result);
          }
      }

      [TestClass]
      public class CalculatorTests
      {
          [TestMethod]
          public void Adding_4_And_3_Should_Return_7()
          {
              var calculator = new Calculator();

              int result = calculator.Add(4, 3);

              Assert.AreEqual(7, result);
          }
      }
    ```

  - 针对异常情况的测试（JUnit）

    ```java
      @Test
      void testExpectedException() {
        ApplicationException thrown = Assertions.assertThrows(ApplicationException.class, () -> {
                //Code under test
        });
        Assertions.assertEquals("some message", exception.getMessage());
      }
    ```

  - 使用最合适的断言方法

    ```java
      List<String> list = Arrays.asList("a", "b", "c");
      List<String> equalList = Arrays.asList("b", "c", "a");
      org.assertj.core.api.Assertions.assertThat(list)
          .containsExactlyInAnyOrderElementsOf(equalList);
    ```

    ```java
      public static void assertEquals(T expected, T actual, String message)
    ```

  - 一些好例子

    ```java
      final class Foo
      {
        // Members and other methods removed for brevity.

        public int bar(final int i)
        {
          if (shouldReturnDefaultValue(i))
          {
            logger.debug("Returning default value for: " + i);
            return DEFAULT_VALUE;
          }
          else
          {
            logger.debug("Returning calculated value for: " + i);
            return calculateValue(i);
          }
        }
      }
    ```

    ```java
      // Don't do this!
      public final class TestFoo
      {
        private FooDependency fooDependency = new FooDependency();

        // rest of test class removed for brevity
      }

      // Do this instead
      public final class TestFoo
      {
        private FooDependency fooDependency;

        @Before
        public void setUp()
        {
          fooDependency = new FooDependency();
        }
      }
    ```

    ```java
      final class Foo
      {
        int foo(int i) throws IOException;
      }
    ```

    ```java
      // Don't do this - it's not necessary to write the try/catch!
      @Test
      public void foo_seven()
      {
        try
        {
          assertEquals(3, new Foo().foo(7));
        }
        catch (final IOException e)
        {
          fail();
        }
      }

      // Do this instead
      @Test
      public void foo_seven() throws Exception
      {
        assertEquals(3, new Foo().foo(7));
      }
    ```

    ```java
      // Don't do this - it's not necessary to write the try/catch!
      @Test
      public void foo_nine()
      {
        boolean wasExceptionThrown = false;
        try
        {
          new Foo().foo(9);
        }
        catch (final IOException e)
        {
          wasExceptionThrown = true;
        }
        assertTrue(wasExceptionThrown);
      }

      // Do this instead
      @Test(expected = IOException.class)
      public void foo_nine() throws Exception
      {
        new Foo().foo(9);
      }
    ```

    ```java
      // Don't do this - it's not necessary to write the try/catch!
      @Test
      public void foo_seven()
      {
        try
        {
          assertEquals(3, new Foo().foo(7));
        }
        catch (final IOException e)
        {
          e.printStackTrace();
        }
      }

      // Do this instead
      @Test
      public void foo_seven() throws Exception
      {
        assertEquals(3, new Foo().foo(7));
      }
    ```

    ```java
      // Don't do this - the throws clause is too specific!
      @Test
      public void foo_seven() throws IOException
      {
        assertEquals(3, new Foo().foo(7));
      }

      // Don't do this - the throws clause is too specific!
      @Test
      public void foo_seven() throws IOException, GeneralSecurityException
      {
        assertEquals(3, new Foo().foo(7));
      }

      // Do this instead
      @Test
      public void foo_seven() throws Exception
      {
        assertEquals(3, new Foo().foo(7));
      }
    ```

## 11.5 贫血模型的传统开发模式
  实际上，你可能一直都在用贫血模型做开发，只是自己不知道而已。不夸张地讲，据我了解，目前几乎所有的业务后端系统，都是基于贫血模型的。我举一个简单的例子来给你解释一下。

  ```java
    ////////// Controller+VO(View Object) //////////
    public class UserController {
      private UserService userService; //通过构造函数或者IOC框架注入
      
      public UserVo getUserById(Long userId) {
        UserBo userBo = userService.getUserById(userId);
        UserVo userVo = [...convert userBo to userVo...];
        return userVo;
      }
    }

    public class UserVo {//省略其他属性、get/set/construct方法
      private Long id;
      private String name;
      private String cellphone;
    }

    ////////// Service+BO(Business Object) //////////
    public class UserService {
      private UserRepository userRepository; //通过构造函数或者IOC框架注入
      
      public UserBo getUserById(Long userId) {
        UserEntity userEntity = userRepository.getUserById(userId);
        UserBo userBo = [...convert userEntity to userBo...];
        return userBo;
      }
    }

    public class UserBo {//省略其他属性、get/set/construct方法
      private Long id;
      private String name;
      private String cellphone;
    }

    ////////// Repository+Entity //////////
    public class UserRepository {
      public UserEntity getUserById(Long userId) { //... }
    }

    public class UserEntity {//省略其他属性、get/set/construct方法
      private Long id;
      private String name;
      private String cellphone;
    }
  ```

## 11.6 充血模型的 DDD 开发模式
  ### 11.6.1 基于贫血模型的传统开发模式
  这是一个典型的 Web 后端项目的三层结构。其中，Controller 和 VO 负责暴露接口，具体的代码实现如下所示。注意，Controller 中，接口实现比较简单，主要就是调用 Service 的方法，所以，我省略了具体的代码实现。
  ```java
    public class VirtualWalletController {
      // 通过构造函数或者IOC框架注入
      private VirtualWalletService virtualWalletService;
      
      public BigDecimal getBalance(Long walletId) { ... } //查询余额
      public void debit(Long walletId, BigDecimal amount) { ... } //出账
      public void credit(Long walletId, BigDecimal amount) { ... } //入账
      public void transfer(Long fromWalletId, Long toWalletId, BigDecimal amount) { ...} //转账
      //省略查询transaction的接口
    }
  ```

  Service 和 BO 负责核心业务逻辑，Repository 和 Entity 负责数据存取。Repository 这一层的代码实现比较简单，不是我们讲解的重点，所以我也省略掉了。Service 层的代码如下所示。注意，这里我省略了一些不重要的校验代码，比如，对 amount 是否小于 0、钱包是否存在的校验等等。

  ```java       
    public class VirtualWalletBo {//省略getter/setter/constructor方法
      private Long id;
      private Long createTime;
      private BigDecimal balance;
    }

    public enum TransactionType {
      DEBIT,
      CREDIT,
      TRANSFER;
    }

    public class VirtualWalletService {
      // 通过构造函数或者IOC框架注入
      private VirtualWalletRepository walletRepo;
      private VirtualWalletTransactionRepository transactionRepo;
      
      public VirtualWalletBo getVirtualWallet(Long walletId) {
        VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);
        VirtualWalletBo walletBo = convert(walletEntity);
        return walletBo;
      }
      
      public BigDecimal getBalance(Long walletId) {
        return walletRepo.getBalance(walletId);
      }

      @Transactional
      public void debit(Long walletId, BigDecimal amount) {
        VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);
        BigDecimal balance = walletEntity.getBalance();
        if (balance.compareTo(amount) < 0) {
          throw new NoSufficientBalanceException(...);
        }
        VirtualWalletTransactionEntity transactionEntity = new VirtualWalletTransactionEntity();
        transactionEntity.setAmount(amount);
        transactionEntity.setCreateTime(System.currentTimeMillis());
        transactionEntity.setType(TransactionType.DEBIT);
        transactionEntity.setFromWalletId(walletId);
        transactionRepo.saveTransaction(transactionEntity);
        walletRepo.updateBalance(walletId, balance.subtract(amount));
      }

      @Transactional
      public void credit(Long walletId, BigDecimal amount) {
        VirtualWalletTransactionEntity transactionEntity = new VirtualWalletTransactionEntity();
        transactionEntity.setAmount(amount);
        transactionEntity.setCreateTime(System.currentTimeMillis());
        transactionEntity.setType(TransactionType.CREDIT);
        transactionEntity.setFromWalletId(walletId);
        transactionRepo.saveTransaction(transactionEntity);
        VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);
        BigDecimal balance = walletEntity.getBalance();
        walletRepo.updateBalance(walletId, balance.add(amount));
      }

      @Transactional
      public void transfer(Long fromWalletId, Long toWalletId, BigDecimal amount) {
        VirtualWalletTransactionEntity transactionEntity = new VirtualWalletTransactionEntity();
        transactionEntity.setAmount(amount);
        transactionEntity.setCreateTime(System.currentTimeMillis());
        transactionEntity.setType(TransactionType.TRANSFER);
        transactionEntity.setFromWalletId(fromWalletId);
        transactionEntity.setToWalletId(toWalletId);
        transactionRepo.saveTransaction(transactionEntity);
        debit(fromWalletId, amount);
        credit(toWalletId, amount);
      }
    }
  ```

### 11.6.2 基于充血模型的 DDD 开发模式

在这种开发模式下，我们把虚拟钱包 VirtualWallet 类设计成一个充血的 Domain 领域模型，并且将原来在 Service 类中的部分业务逻辑移动到 VirtualWallet 类中，让 Service 类的实现依赖 VirtualWallet 类。具体的代码实现如下所示：<br>

```java
  public class VirtualWallet { // Domain领域模型(充血模型)
    private Long id;
    private Long createTime = System.currentTimeMillis();;
    private BigDecimal balance = BigDecimal.ZERO;
    
    public VirtualWallet(Long preAllocatedId) {
      this.id = preAllocatedId;
    }
    
    public BigDecimal balance() {
      return this.balance;
    }
    
    public void debit(BigDecimal amount) {
      if (this.balance.compareTo(amount) < 0) {
        throw new InsufficientBalanceException(...);
      }
      this.balance = this.balance.subtract(amount);
    }
    
    public void credit(BigDecimal amount) {
      if (amount.compareTo(BigDecimal.ZERO) < 0) {
        throw new InvalidAmountException(...);
      }
      this.balance = this.balance.add(amount);
    }
  }

  public class VirtualWalletService {
    // 通过构造函数或者IOC框架注入
    private VirtualWalletRepository walletRepo;
    private VirtualWalletTransactionRepository transactionRepo;
    
    public VirtualWallet getVirtualWallet(Long walletId) {
      VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);
      VirtualWallet wallet = convert(walletEntity);
      return wallet;
    }
    
    public BigDecimal getBalance(Long walletId) {
      return walletRepo.getBalance(walletId);
    }
    
    @Transactional
    public void debit(Long walletId, BigDecimal amount) {
      VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);
      VirtualWallet wallet = convert(walletEntity);
      wallet.debit(amount);
      VirtualWalletTransactionEntity transactionEntity = new VirtualWalletTransactionEntity();
      transactionEntity.setAmount(amount);
      transactionEntity.setCreateTime(System.currentTimeMillis());
      transactionEntity.setType(TransactionType.DEBIT);
      transactionEntity.setFromWalletId(walletId);
      transactionRepo.saveTransaction(transactionEntity);
      walletRepo.updateBalance(walletId, wallet.balance());
    }
    
    @Transactional
    public void credit(Long walletId, BigDecimal amount) {
      VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);
      VirtualWallet wallet = convert(walletEntity);
      wallet.credit(amount);
      VirtualWalletTransactionEntity transactionEntity = new VirtualWalletTransactionEntity();
      transactionEntity.setAmount(amount);
      transactionEntity.setCreateTime(System.currentTimeMillis());
      transactionEntity.setType(TransactionType.CREDIT);
      transactionEntity.setFromWalletId(walletId);
      transactionRepo.saveTransaction(transactionEntity);
      walletRepo.updateBalance(walletId, wallet.balance());
    }

    @Transactional
    public void transfer(Long fromWalletId, Long toWalletId, BigDecimal amount) {
      //...跟基于贫血模型的传统开发模式的代码一样...
    }
  }
```

看了上面的代码，你可能会说，领域模型 VirtualWallet 类很单薄，包含的业务逻辑很简单。相对于原来的贫血模型的设计思路，这种充血模型的设计思路，貌似并没有太大优势。你说得没错！这也是大部分业务系统都使用基于贫血模型开发的原因。不过，如果虚拟钱包系统需要支持更复杂的业务逻辑，那充血模型的优势就显现出来了。比如，我们要支持透支一定额度和冻结部分余额的功能。这个时候，我们重新来看一下 VirtualWallet 类的实现代码。
```java
  public class VirtualWallet {
    private Long id;
    private Long createTime = System.currentTimeMillis();;
    private BigDecimal balance = BigDecimal.ZERO;
    private boolean isAllowedOverdraft = true;
    private BigDecimal overdraftAmount = BigDecimal.ZERO;
    private BigDecimal frozenAmount = BigDecimal.ZERO;
    
    public VirtualWallet(Long preAllocatedId) {
      this.id = preAllocatedId;
    }
    
    public void freeze(BigDecimal amount) { ... }
    public void unfreeze(BigDecimal amount) { ...}
    public void increaseOverdraftAmount(BigDecimal amount) { ... }
    public void decreaseOverdraftAmount(BigDecimal amount) { ... }
    public void closeOverdraft() { ... }
    public void openOverdraft() { ... }
    
    public BigDecimal balance() {
      return this.balance;
    }
    
    public BigDecimal getAvaliableBalance() {
      BigDecimal totalAvaliableBalance = this.balance.subtract(this.frozenAmount);
      if (isAllowedOverdraft) {
        totalAvaliableBalance += this.overdraftAmount;
      }
      return totalAvaliableBalance;
    }
    
    public void debit(BigDecimal amount) {
      BigDecimal totalAvaliableBalance = getAvaliableBalance();
      if (totoalAvaliableBalance.compareTo(amount) < 0) {
        throw new InsufficientBalanceException(...);
      }
      this.balance = this.balance.subtract(amount);
    }
    
    public void credit(BigDecimal amount) {
      if (amount.compareTo(BigDecimal.ZERO) < 0) {
        throw new InvalidAmountException(...);
      }
      this.balance = this.balance.add(amount);
    }
  }
```
领域模型 VirtualWallet 类添加了简单的冻结和透支逻辑之后，功能看起来就丰富了很多，代码也没那么单薄了。如果功能继续演进，我们可以增加更加细化的冻结策略、透支策略、支持钱包账号（VirtualWallet id 字段）自动生成的逻辑（不是通过构造函数经外部传入 ID，而是通过分布式 ID 生成算法来自动生成 ID）等等。VirtualWallet 类的业务逻辑会变得越来越复杂，也就很值得设计成充血模型了。



## 11.7 IoC容器和Dependency Injection模式

在这个例子中，我编写了一个组件，用于提供一份电影清单，清单上列出的影片都是由一位特定的导演执导的。实现这个伟大的功能只需要一个方法：
```java
  class MovieLister...

    public Movie[] moviesDirectedBy(String arg)
    {
        List allMovies = finder.findAll();
        for (Iterator it = allMovies.iterator(); it.hasNext();)
        {
            Movie movie = (Movie) it.next();
            if (!movie.getDirector().equals(arg))
            {
                it.remove();
            }

        }
        return (Movie[]) allMovies.toArray(new Movie[allMovies.size()]);
    }
```
你可以看到，这个功能的实现极其简单：moviesDirectedBy方法首先请求finder（影片搜寻者）对象（我们稍后会谈到这个对象）返回后者所知道的所有影片，然后遍历finder对象返回的清单，并返回其中由特定的某个导演执导的影片。非常简单，不过不必担心，这只是整个例子的脚手架罢了。我们真正想要考察的是finder对象，或者说，如何将MovieLister对象与特定的finder对象连接起来。为什么我们对这个问题特别感兴趣？因为我希望上面这个漂亮的moviesDirectedBy方法完全不依赖于影片的实际存储方式。所以，这个方法只能引用一个finder对象，而finder对象则必须知道如何对findAll 方法作出回应。为了帮助读者更清楚地理解，我给finder定义了一个接口：

```java
  public interface MovieFinder
  {
      List findAll();
  }
```

现在，两个对象之间没有什么耦合关系。但是，当我要实际寻找影片时，就必须涉及到MovieFinder的某个具体子类。在这里，我把涉及具体子类的代码放在MovieLister类的构造函数中。
```java
  class MovieLister...
    private MovieFinder finder;
    public MovieLister()
    {
        finder = new ColonDelimitedMovieFinder("movies1.txt");
    }
```

PicoContainer通过构造函数来判断如何将MovieFinder实例注入MovieLister 类。因此，MovieLister类必须声明一个构造函数，并在其中包含所有需要注入的元素：
```java
  class MovieLister...
    public MovieLister(MovieFinder finder)
    {
        this.finder = finder;
    }
```

MovieFinder实例本身也将由PicoContainer来管理，因此文本文件的名字也可以由容器注入：
```java
class ColonMovieFinder...
    public ColonMovieFinder(String filename)
    {
        this.filename = filename;
    }
```

随后，需要告诉PicoContainer：各个接口分别与哪个实现类关联、将哪个字符串注入MovieFinder组件。
```java
  private MutablePicoContainer configureContainer()
  {
      MutablePicoContainer pico = new DefaultPicoContainer();
      Parameter[] finderParams = {newConstantParameter("movies1.txt")};
      pico.registerComponentImplementation(MovieFinder.class,ColonMovieFinder.class, finderParams);
      pico.registerComponentImplementation(MovieLister.class);
      return pico;
  }
```
使用这个容器，你写出的代码大概会是这样：
```java
  public void testWithPico()
  {
      MutablePicoContainer pico = configureContainer();
      MovieLister lister = (MovieLister)pico.getComponentInstance(MovieLister.class);
      Movie[] movies = lister.moviesDirectedBy("Sergio Leone");
      assertEquals("Once Upon a Time in the West",movies[0].getTitle());
  }
```

Spring 框架是一个用途广泛的企业级Java 开发框架，其中包括了针对事务、持久化框架、web应用开发和JDBC等常用功能的抽象。和PicoContainer一样，它也同时支持构造函数注入和设值方法注入，但该项目的开发者更推荐使用设值方法注入——恰好适合这个例子。为了让MovieLister类接受注入，我需要为它定义一个设值方法，该方法接受类型为MovieFinder的参数：

```java
class MovieLister...
    private MovieFinder finder;
    public void setFinder(MovieFinder finder)
    {
        this.finder = finder;
    }
```

类似地，在MovieFinder的实现类中，我也定义了一个设值方法，接受类型为String 的参数：
```java
  class ColonMovieFinder...
    public void setFilename(String filename)
    {
        this.filename = filename;
    }
```

第三步是设定配置文件。Spring 支持多种配置方式，你可以通过XML 文件进行配置，也可以直接在代码中配置。不过，XML 文件是比较理想的配置方式。
```xml
  <beans>
    <bean id="MovieLister" class="spring.MovieLister">
        <property name="finder">
            <ref local="MovieFinder"/>
        </property>
    </bean>
    <bean id="MovieFinder" class="spring.ColonMovieFinder">
        <property name="filename">
            <value>movies1.txt</value>
        </property>
    </bean>
  </beans>
```
于是，测试代码大概就像下面这样：
```java
    public void testWithSpring() throws Exception
    {
        ApplicationContext ctx = newFileSystemXmlApplicationContext("spring.xml");
        MovieLister lister = (MovieLister) ctx.getBean("MovieLister");
        Movie[] movies = lister.moviesDirectedBy("Sergio Leone");
        assertEquals("Once Upon a Time in the West",movies[0].getTitle());
    }
```

除了前面两种注入技术，还可以在接口中定义需要注入的信息，并通过接口完成注入。Avalon框架就使用了类似的技术。在这里，我首先用简单的范例代码说明它的用法，后面还会有更深入的讨论。首先，我需要定义一个接口，组件的注入将通过这个接口进行。在本例中，这个接口的用途是将一个MovieFinder实例注入继承了该接口的对象。
```java
  public interface InjectFinder
  {
      void injectFinder(MovieFinder finder);
  }
```

这个接口应该由提供MovieFinder接口的人一并提供。任何想要使用MovieFinder实例的类（例如MovieLister类）都必须实现这个接口。
```java
  class MovieLister implements InjectFinder...
    public void injectFinder(MovieFinder finder)
    {
        this.finder = finder;
    }
```

然后，我使用类似的方法将文件名注入MovieFinder的实现类：
```java
  public interface InjectFilename
  {
      void injectFilename (String filename);
  }

  class ColonMovieFinder implements MovieFinder, InjectFilename...
      public void injectFilename(String filename)
      {
          this.filename = filename;
      }
```

现在，还需要用一些配置代码将所有的组件实现装配起来。简单起见，我直接在代码中完成配置，并将配置好的MovieLister 对象保存在名为lister的字段中：
```java
  class IfaceTester...
    private MovieLister lister;
    private void configureLister()
    {
        ColonMovieFinder finder = new ColonMovieFinder();
        finder.injectFilename("movies1.txt");
        lister = new MovieLister();
        lister.injectFinder(finder);
    }
```

测试代码则可以直接使用这个字段：
```java
  class IfaceTester...
    public void testIface()
    {
        configureLister();
        Movie[] movies = lister.moviesDirectedBy("Sergio Leone");
        assertEquals("Once Upon a Time in the West",movies[0].getTitle());
    }
```

在这里，我把ServiceLocator类实现为一个Singleton的注册表，于是MovieLister就可以在实例化时通过ServiceLocator获得一个MovieFinder实例。

```java
  class MovieLister...
    MovieFinder finder = ServiceLocator.movieFinder();

  class ServiceLocator...
      public static MovieFinder movieFinder()
      {
          return soleInstance.movieFinder;
      }
      private static ServiceLocator soleInstance;
      private MovieFinder movieFinder;
```

和注入的方式一样，我们也必须对服务定位器加以配置。在这里，我直接在代码中进行配置，但设计一种通过配置文件获得数据的机制也并非难事。
```java
  class Tester...
    private void configure()
    {
        ServiceLocator.load(new ServiceLocator(
        newColonMovieFinder("movies1.txt")));
    }

  class ServiceLocator...
      public static void load(ServiceLocator arg)
      {
          soleInstance = arg;
      }
      public ServiceLocator(MovieFinder movieFinder)
      {
      this.movieFinder = movieFinder;
      }
```

下面是测试代码：

```java
  class Tester...
    public void testSimple()
    {
        configure();
        MovieLister lister = new MovieLister();
        Movie[] movies = lister.moviesDirectedBy("Sergio Leone");
        assertEquals("Once Upon a Time in the West",movies[0].getTitle());

    }
```

此时，MovieLister 类的提供者也应该一并提供一个定位器接口，使用者可以通过这个接口获得MovieFinder实例。
```java
  public interface MovieFinderLocator
  {
    public MovieFinder movieFinder();
```

真实的服务定位器需要实现上述接口，提供访问MovieFinder实例的能力：
```java
    MovieFinderLocator locator = ServiceLocator.locator();
    MovieFinder finder = locator.movieFinder();
    public static ServiceLocator locator()
    {
      return soleInstance;
    }
    public MovieFinder movieFinder()
    {
        return movieFinder;
    }
    private static ServiceLocator soleInstance;
    private MovieFinder movieFinder;
```
在本例中，ServiceLocator使用一个map来保存服务信息，而不再是将这些信息保存在字段中。此外，ServiceLocator还提供了一个通用的方法，用于获取和加载服务对象。
```java
  class ServiceLocator...
    private static ServiceLocator soleInstance;
    public static void load(ServiceLocator arg)
    {
        soleInstance = arg;
    }
    private Map services = new HashMap();
    public static Object getService(String key)
    {
        return soleInstance.services.get(key);
    }
    public void loadService (String key, Object service)
    {
        services.put(key, service);
    }
```

同样需要对服务定位器进行配置，将服务对象与适当的关键字加载到定位器中：

```java
  class Tester...
    private void configure()
    {
        ServiceLocator locator = new ServiceLocator();
        locator.loadService("MovieFinder", newColonMovieFinder("movies1.txt"));
        ServiceLocator.load(locator);
    }
```

我使用与服务对象类名称相同的字符串作为服务对象的关键字：

```java
  class MovieLister...
    MovieFinder finder = (MovieFinder)
    ServiceLocator.getService("MovieFinder");
```

对于前面一直使用的例子，Berin Loritsch发送给了我一个简单的Avalon实现版本：
```java
  public class MyMovieLister implements MovieLister, Serviceable
  {
    private MovieFinder finder;
    public void service( ServiceManager manager )throws ServiceException
    {
        finder = (MovieFinder)manager.lookup("finder");
    }
```


## 11.8 设计模式二三事

**奖励的发放策略：**
<br>因为之前有过类似的开发经验，拿到需求的小明二话不说开始了编写起了代码：
```java
  // 奖励服务
  class RewardService {
      // 外部服务
      private WaimaiService waimaiService;
      private HotelService hotelService;
      private FoodService foodService;
      // 使用对入参的条件判断进行发奖
      public void issueReward(String rewardType, Object ... params) {
          if ("Waimai".equals(rewardType)) {
              WaimaiRequest request = new WaimaiRequest();
              // 构建入参
              request.setWaimaiReq(params);
              waimaiService.issueWaimai(request);
          } else if ("Hotel".equals(rewardType)) {
              HotelRequest request = new HotelRequest();
              request.addHotelReq(params);
              hotelService.sendPrize(request);
          } else if ("Food".equals(rewardType)) {
              FoodRequest request = new FoodRequest(params);
              foodService.getCoupon(request);
          } else {
              throw new IllegalArgumentException("rewardType error!");
          }
      }
  }
```

结合优化思路，小明首先设计出了策略接口，并通过适配器的思想将各个下游接口类适配成策略类：
```java
  // 策略接口
  interface Strategy {
      void issue(Object ... params);
  }
  // 外卖策略
  class Waimai implements Strategy {
      private WaimaiService waimaiService;
      @Override
      public void issue(Object... params) {
          WaimaiRequest request = new WaimaiRequest();
          // 构建入参
          request.setWaimaiReq(params);
          waimaiService.issueWaimai(request);
      }
  }
  // 酒旅策略
  class Hotel implements Strategy {
      private HotelService hotelService;
      @Override
      public void issue(Object... params) {
          HotelRequest request = new HotelRequest();
          request.addHotelReq(params);
          hotelService.sendPrize(request);
      }
  }
  // 美食策略
  class Food implements Strategy {
      private FoodService foodService;
      @Override
      public void issue(Object... params) {
          FoodRequest request = new FoodRequest(params);
          foodService.payCoupon(request);
      }
  }
```

然后，小明创建策略模式的环境类，并供奖励服务调用：
```java
  // 使用分支判断获取的策略上下文
  class StrategyContext {
      public static Strategy getStrategy(String rewardType) {
          switch (rewardType) {
              case "Waimai":
                  return new Waimai();
              case "Hotel":
                  return new Hotel();
              case "Food":
                  return new Food();
              default:
                  throw new IllegalArgumentException("rewardType error!");
          }
      }
  }
  // 优化后的策略服务
  class RewardService {
      public void issueReward(String rewardType, Object ... params) {
          Strategy strategy = StrategyContext.getStrategy(rewardType);
          strategy.issue(params);
      }
  }
```

最终，小明在策略环境类中使用一个注册表来记录各个策略类的注册信息，并提供接口供策略类调用进行注册。同时使用饿汉式单例模式去优化策略类的设计：
```java
  // 策略上下文，用于管理策略的注册和获取
  class StrategyContext {
      private static final Map<String, Strategy> registerMap = new HashMap<>();
      // 注册策略
      public static void registerStrategy(String rewardType, Strategy strategy) {
          registerMap.putIfAbsent(rewardType, strategy);
      }
      // 获取策略
      public static Strategy getStrategy(String rewardType) {
          return registerMap.get(rewardType);
      }
  }
  // 抽象策略类
  abstract class AbstractStrategy implements Strategy {
      // 类注册方法
      public void register() {
          StrategyContext.registerStrategy(getClass().getSimpleName(), this);
      }
  }
  // 单例外卖策略
  class Waimai extends AbstractStrategy implements Strategy {
      private static final Waimai instance = new Waimai();
      private WaimaiService waimaiService;
      private Waimai() {
          register();
      }
      public static Waimai getInstance() {
          return instance;
      }
      @Override
      public void issue(Object... params) {
          WaimaiRequest request = new WaimaiRequest();
          // 构建入参
          request.setWaimaiReq(params);
          waimaiService.issueWaimai(request);
      }
  }
  // 单例酒旅策略
  class Hotel extends AbstractStrategy implements Strategy {
      private static final Hotel instance = new Hotel();
      private HotelService hotelService;
      private Hotel() {
          register();
      }
      public static Hotel getInstance() {
          return instance;
      }
      @Override
      public void issue(Object... params) {
          HotelRequest request = new HotelRequest();
          request.addHotelReq(params);
          hotelService.sendPrize(request);
      }
  }
  // 单例美食策略
  class Food extends AbstractStrategy implements Strategy {
      private static final Food instance = new Food();
      private FoodService foodService;
      private Food() {
          register();
      }
      public static Food getInstance() {
          return instance;
      }
      @Override
      public void issue(Object... params) {
          FoodRequest request = new FoodRequest(params);
          foodService.payCoupon(request);
      }
  }
```

**任务模型的设计**<br>
小明欣然接下了老师给的难题。他首先定义了一套任务状态的枚举和行为的枚举：
```java
  // 任务状态枚举
  @AllArgsConstructor
  @Getter
  enum TaskState {
      INIT("初始化"),
      ONGOING( "进行中"),
      PAUSED("暂停中"),
      FINISHED("已完成"),
      EXPIRED("已过期")
      ;
      private final String message;
  }
  // 行为枚举
  @AllArgsConstructor
  @Getter
  enum ActionType {
      START(1, "开始"),
      STOP(2, "暂停"),
      ACHIEVE(3, "完成"),
      EXPIRE(4, "过期")
      ;
      private final int code;
      private final String message;
  }
```
然后，小明对开始编写状态变更功能：
```java
  class Task {
      private Long taskId;
      // 任务的默认状态为初始化
      private TaskState state = TaskState.INIT;
      // 活动服务
      private ActivityService activityService;
      // 任务管理器
      private TaskManager taskManager;
      // 使用条件分支进行任务更新
      public void updateState(ActionType actionType) {
          if (state == TaskState.INIT) {
              if (actionType == ActionType.START) {
                  state = TaskState.ONGOING;
              }
          } else if (state == TaskState.ONGOING) {
              if (actionType == ActionType.ACHIEVE) {
                  state = TaskState.FINISHED;
                  // 任务完成后进对外部服务进行通知
                  activityService.notifyFinished(taskId);
                  taskManager.release(taskId);
              } else if (actionType == ActionType.STOP) {
                  state = TaskState.PAUSED;
              } else if (actionType == ActionType.EXPIRE) {
                  state = TaskState.EXPIRED;
              }
          } else if (state == TaskState.PAUSED) {
              if (actionType == ActionType.START) {
                  state = TaskState.ONGOING;
              } else if (actionType == ActionType.EXPIRE) {
                  state = TaskState.EXPIRED;
              }
          }
      }
  }
```

根据状态模式的定义，小明将TaskState枚举类扩展成多个状态类，并具备完成状态的流转的能力；然后优化了任务类的实现：
```java
  // 任务状态抽象接口
  interface State {
      // 默认实现，不做任何处理
      default void update(Task task, ActionType actionType) {
          // do nothing
      }
  }
  // 任务初始状态
  class TaskInit implements State {
      @Override
      public void update(Task task, ActionType actionType) {
          if  (actionType == ActionType.START) {
              task.setState(new TaskOngoing());
          }
      }
  }
  // 任务进行状态
  class TaskOngoing implements State {
      private ActivityService activityService;
      private TaskManager taskManager; 
      @Override
      public void update(Task task, ActionType actionType) {
          if (actionType == ActionType.ACHIEVE) {
              task.setState(new TaskFinished());
              // 通知
              activityService.notifyFinished(taskId);
              taskManager.release(taskId);
          } else if (actionType == ActionType.STOP) {
              task.setState(new TaskPaused());
          } else if (actionType == ActionType.EXPIRE) {
              task.setState(new TaskExpired());
          }
      }
  }
  // 任务暂停状态
  class TaskPaused implements State {
      @Override
      public void update(Task task, ActionType actionType) {
          if (actionType == ActionType.START) {
              task.setState(new TaskOngoing());
          } else if (actionType == ActionType.EXPIRE) {
              task.setState(new TaskExpired());
          }
      }
  }
  // 任务完成状态
  class TaskFinished implements State {

  }
  // 任务过期状态
  class TaskExpired implements State {

  }
  @Data
  class Task {
      private Long taskId;
      // 初始化为初始态
      private State state = new TaskInit();
      // 更新状态
      public void updateState(ActionType actionType) {
          state.update(this, actionType);
      }
  }
```

小明首先设计好抽象目标和抽象观察者，然后将活动和任务管理器的接收通知功能定制成具体观察者：
```java
  // 抽象观察者
  interface Observer {
      void response(Long taskId); // 反应
  }
  // 抽象目标
  abstract class Subject {
      protected List<Observer> observers = new ArrayList<Observer>();
      // 增加观察者方法
      public void add(Observer observer) {
          observers.add(observer);
      }
      // 删除观察者方法
      public void remove(Observer observer) {
          observers.remove(observer);
      }
      // 通知观察者方法
      public void notifyObserver(Long taskId) {
          for (Observer observer : observers) {
              observer.response(taskId);
          }
      }
  }
  // 活动观察者
  class ActivityObserver implements Observer {
      private ActivityService activityService;
      @Override
      public void response(Long taskId) {
          activityService.notifyFinished(taskId);
      }
  }
  // 任务管理观察者
  class TaskManageObserver implements Observer {
      private TaskManager taskManager;
      @Override
      public void response(Long taskId) {
          taskManager.release(taskId);
      }
  }
```

最后，小明将任务进行状态类优化成使用通用的通知方法，并在任务初始态执行状态流转时定义任务进行态所需的观察者：
```java
  // 任务进行状态
  class TaskOngoing extends Subject implements State {  
      @Override
      public void update(Task task, ActionType actionType) {
          if (actionType == ActionType.ACHIEVE) {
              task.setState(new TaskFinished());
              // 通知
              notifyObserver(task.getTaskId());
          } else if (actionType == ActionType.STOP) {
              task.setState(new TaskPaused());
          } else if (actionType == ActionType.EXPIRE) {
              task.setState(new TaskExpired());
          }
      }
  }
  // 任务初始状态
  class TaskInit implements State {
      @Override
      public void update(Task task, ActionType actionType) {
          if  (actionType == ActionType.START) {
              TaskOngoing taskOngoing = new TaskOngoing();
              taskOngoing.add(new ActivityObserver());
              taskOngoing.add(new TaskManageObserver());
              task.setState(taskOngoing);
          }
      }
  }
```

**活动的迭代重构**<br>
活动模型的特点在于其组成部分较多，小明原先的活动模型的构建方式是这样的：
```java
  // 抽象活动接口
  interface ActivityInterface {
      void participate(Long userId);
  }
  // 活动类
  class Activity implements ActivityInterface {
      private String type;
      private Long id;
      private String name;
      private Integer scene;
      private String material;
        
      public Activity(String type) {
          this.type = type;
          // id的构建部分依赖于活动的type
          if ("period".equals(type)) {
              id = 0L;
          }
      }
      public Activity(String type, Long id) {
          this.type = type;
          this.id = id;
      }
      public Activity(String type, Long id, Integer scene) {
          this.type = type;
          this.id = id;
          this.scene = scene;
      }
      public Activity(String type, String name, Integer scene, String material) {
          this.type = type;
          this.scene = scene;
          this.material = material;
          // name的构建完全依赖于活动的type
          if ("period".equals(type)) {
              this.id = 0L;
              this.name = "period" + name;
          } else {
              this.name = "normal" + name;
          }
      }
      // 参与活动
      @Override
      public void participate(Long userId) {
          // do nothing
      }
  }
  // 任务型活动
  class TaskActivity extends Activity {
      private Task task;
      public TaskActivity(String type, String name, Integer scene, String material, Task task) {
          super(type, name, scene, material);
          this.task = task;
      }
      // 参与任务型活动
      @Override
      public void participate(Long userId) {
          // 更新任务状态为进行中
          task.getState().update(task, ActionType.START);
      }
  }
```

根据建造者模式的定义，上述活动的每个字段都是一个产品。于是，小明可以通过在活动里面实现静态的建造者类来简易地实现：

```java
  // 活动类
  class Activity implements ActivityInterface {
      protected String type;
      protected Long id;
      protected String name;
      protected Integer scene;
      protected String material;
      // 全参构造函数
      public Activity(String type, Long id, String name, Integer scene, String material) {
          this.type = type;
          this.id = id;
          this.name = name;
          this.scene = scene;
          this.material = material;
      }
      @Override
      public void participate(Long userId) {
          // do nothing
      }
      // 静态建造器类，使用奇异递归模板模式允许继承并返回继承建造器类
      public static class Builder<T extends Builder<T>> {
          protected String type;
          protected Long id;
          protected String name;
          protected Integer scene;
          protected String material;
          public T setType(String type) {
              this.type = type;
              return (T) this;
          }
          public T setId(Long id) {
              this.id = id;
              return (T) this;
          }
          public T setId() {
              if ("period".equals(this.type)) {
                  this.id = 0L;
              }
              return (T) this;
          }
          public T setScene(Integer scene) {
              this.scene = scene;
              return (T) this;
          }
          public T setMaterial(String material) {
              this.material = material;
              return (T) this;
          }
          public T setName(String name) {
              if ("period".equals(this.type)) {
                  this.name = "period" + name;
              } else {
                  this.name = "normal" + name;
              }
              return (T) this;
          }
          public Activity build(){
              return new Activity(type, id, name, scene, material);
          }
      }
  }
  // 任务型活动
  class TaskActivity extends Activity {
      protected Task task;
      // 全参构造函数
      public TaskActivity(String type, Long id, String name, Integer scene, String material, Task task) {
          super(type, id, name, scene, material);
          this.task = task;
      }
      // 参与任务型活动
      @Override
      public void participate(Long userId) {
          // 更新任务状态为进行中
          task.getState().update(task, ActionType.START);
      }
      // 继承建造器类
      public static class Builder extends Activity.Builder<Builder> {
          private Task task;
          public Builder setTask(Task task) {
              this.task = task;
              return this;
          }
          public TaskActivity build(){
              return new TaskActivity(type, id, name, scene, material, task);
          }
      }
  }
```

重构完活动构建的设计后，小明开始对参加活动方法增加风控。最简单的方式肯定是直接修改目标方法：
```java
  public void participate(Long userId) {
    // 对目标用户做风险控制，失败则抛出异常
    Risk.doControl(userId);
    // 更新任务状态为进行中
    task.state.update(task, ActionType.START);
  }
```

小明使用了装饰器模式后，新的代码就变成了这样：
```java
  // 抽象装饰角色
  abstract class ActivityDecorator implements ActivityInterface {
      protected ActivityInterface activity;
      public ActivityDecorator(ActivityInterface activity) {
          this.activity = activity;
      }
      public abstract void participate(Long userId);
  }
  // 能够对活动做风险控制的包装类
  class RiskControlDecorator extends ActivityDecorator {
      public RiskControlDecorator(ActivityInterface activity) {
          super(activity);
      }
      @Override
      public void participate(Long userId) {
          // 对目标用户做风险控制，失败则抛出异常
          Risk.doControl(userId);
          // 更新任务状态为进行中
          activity.participate(userId);
      }
  }
```

## 11.9 设计模式在外卖营销业务中的实践

我们通过一段较为通用的代码来解释如何使用工厂模式：
```java
  //抽象的产品
  public abstract class Product {
      public abstract void method();
  }
  //定义一个具体的产品 (可以定义多个具体的产品)
  class ProductA extends Product {
      @Override
      public void method() {}  //具体的执行逻辑
  }
  //抽象的工厂
  abstract class Factory<T> {
      abstract Product createProduct(Class<T> c);
  }
  //具体的工厂可以生产出相应的产品
  class FactoryA extends Factory{
      @Override
      Product createProduct(Class c) {
          Product product = (Product) Class.forName(c.getName()).newInstance();
          return product;
      }
  }
```

我们通过一段比较通用的代码来解释怎么使用策略模式：
```java
  //定义一个策略接口
  public interface Strategy {
      void strategyImplementation();
  }
  ​
  //具体的策略实现(可以定义多个具体的策略实现)
  public class StrategyA implements Strategy{
      @Override
      public void strategyImplementation() {
          System.out.println("正在执行策略A");
      }
  }
  ​
  //封装策略，屏蔽高层模块对策略、算法的直接访问，屏蔽可能存在的策略变化
  public class Context {
      private Strategy strategy = null;
  ​
      public Context(Strategy strategy) {
          this.strategy = strategy;
      }
    
      public void doStrategy() {
          strategy.strategyImplementation();
      }
  }
```

首先确定我们需要生成出n种不同的返奖策略，其编码如下：

```java
  //抽象策略
  public abstract class RewardStrategy {
      public abstract void reward(long userId);
    
      public void insertRewardAndSettlement(long userId, int reward) {} ; //更新用户信息以及结算
  }
  //新用户返奖具体策略A
  public class NewUserRewardStrategyA extends RewardStrategy {
      @Override
      public void reward(long userId) {}  //具体的计算逻辑，...
  }
  ​
  //老用户返奖具体策略A
  public class OldUserRewardStrategyA extends RewardStrategy {
      @Override
      public void reward(long userId) {}  //具体的计算逻辑，...
  }
  ​
  //抽象工厂
  public abstract class StrategyFactory<T> {
      abstract RewardStrategy createStrategy(Class<T> c);
  }
  ​
  //具体工厂创建具体的策略
  public class FactorRewardStrategyFactory extends StrategyFactory {
      @Override
      RewardStrategy createStrategy(Class c) {
          RewardStrategy product = null;
          try {
              product = (RewardStrategy) Class.forName(c.getName()).newInstance();
          } catch (Exception e) {}
          return product;
      }
  }
```

通过工厂模式生产出具体的策略之后，根据我们之前的介绍，很容易就可以想到使用策略模式来执行我们的策略。具体代码如下：
```java
  public class RewardContext {
    private RewardStrategy strategy;
​
    public RewardContext(RewardStrategy strategy) {
        this.strategy = strategy;
    }
​
    public void doStrategy(long userId) { 
        int rewardMoney = strategy.reward(userId);
        insertRewardAndSettlement(long userId, int reward) {
          insertReward(userId, rewardMoney);
          settlement(userId);
       }  
    }
  }
```

接下来我们将工厂模式和策略模式结合在一起，就完成了整个返奖的过程：
```java
  public class InviteRewardImpl {
    //返奖主流程
    public void sendReward(long userId) {
        FactorRewardStrategyFactory strategyFactory = new FactorRewardStrategyFactory();  //创建工厂
        Invitee invitee = getInviteeByUserId(userId);  //根据用户id查询用户信息
        if (invitee.userType == UserTypeEnum.NEW_USER) {  //新用户返奖策略
            NewUserBasicReward newUserBasicReward = (NewUserBasicReward) strategyFactory.createStrategy(NewUserBasicReward.class);
            RewardContext rewardContext = new RewardContext(newUserBasicReward);
            rewardContext.doStrategy(userId); //执行返奖策略
        }if(invitee.userType == UserTypeEnum.OLD_USER){}  //老用户返奖策略，... 
    }
  }
```

接下来，我们通过一段通用代码来解释怎么使用状态模式：
```java
  //定义一个抽象的状态类
  public abstract class State {
      Context context;
      public void setContext(Context context) {
          this.context = context;
      }
      public abstract void handle1();
      public abstract void handle2();
  }
  //定义状态A
  public class ConcreteStateA extends State {
      @Override
      public void handle1() {}  //本状态下必须要处理的事情
  ​
      @Override
      public void handle2() {
          super.context.setCurrentState(Context.contreteStateB);  //切换到状态B        
          super.context.handle2();  //执行状态B的任务
      }
  }
  //定义状态B
  public class ConcreteStateB extends State {
      @Override
      public void handle2() {}  //本状态下必须要处理的事情，...
    
      @Override
      public void handle1() {
          super.context.setCurrentState(Context.contreteStateA);  //切换到状态A
          super.context.handle1();  //执行状态A的任务
      }
  }
  //定义一个上下文管理环境
  public class Context {
      public final static ConcreteStateA contreteStateA = new ConcreteStateA();
      public final static ConcreteStateB contreteStateB = new ConcreteStateB();
  ​
      private State CurrentState;
      public State getCurrentState() {return CurrentState;}
  ​
      public void setCurrentState(State currentState) {
          this.CurrentState = currentState;
          this.CurrentState.setContext(this);
      }
  ​
      public void handle1() {this.CurrentState.handle1();}
      public void handle2() {this.CurrentState.handle2();}
  }
  //定义client执行
  public class client {
      public static void main(String[] args) {
          Context context = new Context();
          context.setCurrentState(new ContreteStateA());
          context.handle1();
          context.handle2();
      }
  }
```


当前的状态只负责当前状态要处理的事情，状态的流转则由第三方类负责。其实践代码如下：

```java
  //返奖状态执行的上下文
  public class RewardStateContext {
  ​
      private RewardState rewardState;
    
      public void setRewardState(RewardState currentState) {this.rewardState = currentState;}
      public RewardState getRewardState() {return rewardState;}
      public void echo(RewardStateContext context, Request request) {
          rewardState.doReward(context, request);
      }
  }
  ​
  public abstract class RewardState {
      abstract void doReward(RewardStateContext context, Request request);
  }
  ​
  //待校验状态
  public class OrderCheckState extends RewardState {
      @Override
      public void doReward(RewardStateContext context, Request request) {
          orderCheck(context, request);  //对进来的订单进行校验，判断是否用券，是否满足优惠条件等等
      }
  }
  ​
  //待补偿状态
  public class CompensateRewardState extends RewardState {
      @Override
      public void doReward(RewardStateContext context, Request request) {
          compensateReward(context, request);  //返奖失败，需要对用户进行返奖补偿
      }
  }
  ​
  //预返奖状态，待返奖状态，成功状态，失败状态(此处逻辑省略)
  //..
  ​
  public class InviteRewardServiceImpl {
      public boolean sendRewardForInvtee(long userId, long orderId) {
          Request request = new Request(userId, orderId);
          RewardStateContext rewardContext = new RewardStateContext();
          rewardContext.setRewardState(new OrderCheckState());
          rewardContext.echo(rewardContext, request);  //开始返奖，订单校验
          //此处的if-else逻辑只是为了表达状态的转换过程，并非实际的业务逻辑
          if (rewardContext.isResultFlag()) {  //如果订单校验成功，进入预返奖状态
              rewardContext.setRewardState(new BeforeRewardCheckState());
              rewardContext.echo(rewardContext, request);
          } else {//如果订单校验失败，进入返奖失败流程，...
              rewardContext.setRewardState(new RewardFailedState());
              rewardContext.echo(rewardContext, request);
              return false;
          }
          if (rewardContext.isResultFlag()) {//预返奖检查成功，进入待返奖流程，...
              rewardContext.setRewardState(new SendRewardState());
              rewardContext.echo(rewardContext, request);
          } else {  //如果预返奖检查失败，进入返奖失败流程，...
              rewardContext.setRewardState(new RewardFailedState());
              rewardContext.echo(rewardContext, request);
              return false;
          }
          if (rewardContext.isResultFlag()) {  //返奖成功，进入返奖结束流程，...
              rewardContext.setRewardState(new RewardSuccessState());
              rewardContext.echo(rewardContext, request);
          } else {  //返奖失败，进入返奖补偿阶段，...
              rewardContext.setRewardState(new CompensateRewardState());
              rewardContext.echo(rewardContext, request);
          }
          if (rewardContext.isResultFlag()) {  //补偿成功，进入返奖完成阶段，...
              rewardContext.setRewardState(new RewardSuccessState());
              rewardContext.echo(rewardContext, request);
          } else {  //补偿失败，仍然停留在当前态，直至补偿成功（或多次补偿失败后人工介入处理）
              rewardContext.setRewardState(new CompensateRewardState());
              rewardContext.echo(rewardContext, request);
          }
          return true;
      }
  }
```

我们通过一段比较通用的代码来解释如何使用责任链模式：
```java
  //定义一个抽象的handle
  public abstract class Handler {
      private Handler nextHandler;  //指向下一个处理者
      private int level;  //处理者能够处理的级别
  ​
      public Handler(int level) {
          this.level = level;
      }
  ​
      public void setNextHandler(Handler handler) {
          this.nextHandler = handler;
      }
  ​
      // 处理请求传递，注意final，子类不可重写
      public final void handleMessage(Request request) {
          if (level == request.getRequstLevel()) {
              this.echo(request);
          } else {
              if (this.nextHandler != null) {
                  this.nextHandler.handleMessage(request);
              } else {
                  System.out.println("已经到最尽头了");
              }
          }
      }
      // 抽象方法，子类实现
      public abstract void echo(Request request);
  }
  ​
  // 定义一个具体的handleA
  public class HandleRuleA extends Handler {
      public HandleRuleA(int level) {
          super(level);
      }
      @Override
      public void echo(Request request) {
          System.out.println("我是处理者1,我正在处理A规则");
      }
  }
  ​
  //定义一个具体的handleB
  public class HandleRuleB extends Handler {}  //...
  ​
  //客户端实现
  class Client {
      public static void main(String[] args) {
          HandleRuleA handleRuleA = new HandleRuleA(1);
          HandleRuleB handleRuleB = new HandleRuleB(2);
          handleRuleA.setNextHandler(handleRuleB);  //这是重点，将handleA和handleB串起来
          handleRuleA.echo(new Request());
      }
  }
```

下面通过代码向大家展示如何实现这一套流程：
```java
  //定义一个抽象的规则
  public abstract class BasicRule<CORE_ITEM, T extends RuleContext<CORE_ITEM>>{
      //有两个方法，evaluate用于判断是否经过规则执行，execute用于执行具体的规则内容。
      public abstract boolean evaluate(T context);
      public abstract void execute(T context);
  }
  ​
  //定义所有的规则具体实现
  //规则1：判断服务可用性
  public class ServiceAvailableRule extends BasicRule<UserPortrait, UserPortraitRuleContext> {
      @Override
      public boolean evaluate(UserPortraitRuleContext context) {
          TakeawayUserPortraitBasicInfo basicInfo = context.getBasicInfo();
          if (basicInfo.isServiceFail()) {
                return false;
          }
          return true;
      }
    
      @Override
      public void execute(UserPortraitRuleContext context) {}
  ​
  }
  //规则2：判断当前用户属性是否符合当前资源位投放的用户属性要求
  public class UserGroupRule extends BasicRule<UserPortrait, UserPortraitRuleContext> {
      @Override
      public boolean evaluate(UserPortraitRuleContext context) {}
    
      @Override
      public void execute(UserPortraitRuleContext context) {
          UserPortrait userPortraitPO = context.getData();
          if(userPortraitPO.getUserGroup() == context.getBasicInfo().getUserGroup().code) {
            context.setValid(true);
          } else {
            context.setValid(false);
          }
      }
  }
    
  //规则3：判断当前用户是否在投放城市，具体逻辑省略
  public class CityInfoRule extends BasicRule<UserPortrait, UserPortraitRuleContext> {}
  //规则4：根据用户的活跃度进行资源过滤，具体逻辑省略
  public class UserPortraitRule extends BasicRule<UserPortrait, UserPortraitRuleContext> {} 
  ​
  //我们通过spring将这些规则串起来组成一个一个请求链
      <bean name="serviceAvailableRule" class="com.dianping.takeaway.ServiceAvailableRule"/>
      <bean name="userGroupValidRule" class="com.dianping.takeaway.UserGroupRule"/>
      <bean name="cityInfoValidRule" class="com.dianping.takeaway.CityInfoRule"/>
      <bean name="userPortraitRule" class="com.dianping.takeaway.UserPortraitRule"/>
        
      <util:list id="userPortraitRuleChain" value-type="com.dianping.takeaway.Rule">
          <ref bean="serviceAvailableRule"/>
          <ref bean="userGroupValidRule"/>
          <ref bean="cityInfoValidRule"/>
          <ref bean="userPortraitRule"/>
      </util:list>
        
  //规则执行
  public class DefaultRuleEngine{
      @Autowired
      List<BasicRule> userPortraitRuleChain;
  ​
      public void invokeAll(RuleContext ruleContext) {
          for(Rule rule : userPortraitRuleChain) {
              rule.evaluate(ruleContext)
          }
      }
  }
```
