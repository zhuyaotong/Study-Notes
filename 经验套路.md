# 11. 经验套路

## 11.1 缓存更新的套路

  - Cache Aside Pattern

    这是最常用最常用的pattern了。其具体逻辑如下：
    - 失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。
    - 命中：应用程序从cache中取数据，取到后返回。
    - 更新：先把数据存到数据库中，成功后，再让缓存失效。

    
      <table>
        <tr>
          <td align="center" style="width: 800px;">
            <img src="https://coolshell.cn/wp-content/uploads/2016/07/Cache-Aside-Design-Pattern-Flow-Diagram-e1470471723210.png" style="width: 1142px;">
            <img src="https://coolshell.cn/wp-content/uploads/2016/07/Updating-Data-using-the-Cache-Aside-Pattern-Flow-Diagram-1-e1470471761402.png" style="width: 1142px;">
          </td>
        </tr>
      </table>

      注意，我们的更新是先更新数据库，成功后，让缓存失效。那么，这种方式是否可以没有文章前面提到过的那个问题呢？我们可以脑补一下。
      一个是查询操作，一个是更新操作的并发，首先，没有了删除cache数据的操作了，而是先更新了数据库中的数据，此时，缓存依然有效，所以，并发的查询操作拿的是没有更新的数据，但是，更新操作马上让缓存的失效了，后续的查询操作再把数据从数据库中拉出来。


## 11.2 XY问题

对于X-Y Problem的意思如下：

1）有人想解决问题X<br>
2）他觉得Y可能是解决X问题的方法<br>
3）但是他不知道Y应该怎么做<br>
4）于是他去问别人Y应该怎么做？

简而言之，没有去问怎么解决问题X，而是去问解决方案Y应该怎么去实现和操作。于是乎：

1）热心的人们帮助并告诉这个人Y应该怎么搞，但是大家都觉得Y这个方案有点怪异。<br>
2）在经过大量地讨论和浪费了大量的时间后，热心的人终于明白了原始的问题X是怎么一回事。<br>
3）于是大家都发现，Y根本就不是用来解决X的合适的方案。

X-Y Problem最大的严重的问题就是：在一个根本错误的方向上浪费他人大量的时间和精力！

## 11.3 如何问问题

  - 提问前先自己尝试查找答案，读读文档、手册，看看有没有相似的问题，看看那些方法能不能帮你解决问题，自己去试一试。如果你是程序员，你应该先学会自己调查一下源代码。（不然，人家回答你的一定是——RTFM – Read The Fucking Manual）这样的问题很多。我有时候很不愿意回答这样的问题，因为我觉得问问题的人把我当成了他的小跟班了。

  - 提问的时候，找正确的人或是正确的论坛发问。向陌生人或是不负责的人提问可能会是很危险的。不正确的人，会让你事倍功半。如果你问Linux的人Windows太慢怎么办？他们一定会让你把Windows删了装Linux去的。

  - 问的问题一定要是很明确的，并且阐述你做了哪些尝试，你一定要简化你的问题，这样可以让你的问题更容易被回答。对于一些问题，最好提供最小化的重现问题的步骤。
  
  - 你一定要让问题变得简单易读，这和写代码是一样的。只有简单易读的邮件，人们才会去读，试想看到一封巨大无比的邮件，读邮件的心情都没有了。而且，内容越多，可能越容易让人理解错了。

  - 你问问题的态度应该是以一种讨论的态度，即不是低三下四，也不是没有底气。只有这样，你和你的问题才能真正被人看得起。要达到这个状态，不想让别人看不起你，你就一定需要自己去做好充足的调查。问题 问得好的话，其实会让人觉得你很有经验的，能想到别人想不到的地方。

  - 不要过早下结论。比如：“我这边的程序不转了，我觉得是你那边的问题，你什么时候能fix？”，或是“太难调试了，gdb怎么这么烂？！”。当你这么做的时候，你一定要有足够的信息和证据，否则，你就显得很自大。好的问题应该是，“我和你的接口的程序有问题，我输入了这样的合法的参数，但是XX函数却总是返回失败，我们能一起看看吗？”，“我看了一下gdb的文档，发现我在用XXX命令调试YYY的时候，有这样ZZZ的问题，是不是我哪里做错了？”

## 11.4 单元测试

  - 一个死的单元测试

    ```C#
      public class Calculator
      {
          public int Add(int x, int y)
          {
              return x + y;
          }
      }

      class Program
      {
          static void Main(string[] args)
          {
              var calculator = new Calculator();

              int result = calculator.Add(5, 6);

              if (result != 11)
                  throw new InvalidOperationException();
          }
      }
    ```
  
  - 好的单元测试（用测试框架）

    ```C#
      [TestClass]
      public class UnitTest1
      {
          [TestMethod]
          public void TestMethod1()
          {
              var calculator = new Calculator();

              int result = calculator.Add(4, 3);

              Assert.AreEqual(7, result);
          }
      }

      [TestClass]
      public class CalculatorTests
      {
          [TestMethod]
          public void Adding_4_And_3_Should_Return_7()
          {
              var calculator = new Calculator();

              int result = calculator.Add(4, 3);

              Assert.AreEqual(7, result);
          }
      }
    ```

  - 针对异常情况的测试（JUnit）

    ```java
      @Test
      void testExpectedException() {
        ApplicationException thrown = Assertions.assertThrows(ApplicationException.class, () -> {
                //Code under test
        });
        Assertions.assertEquals("some message", exception.getMessage());
      }
    ```

  - 使用最合适的断言方法

    ```java
      List<String> list = Arrays.asList("a", "b", "c");
      List<String> equalList = Arrays.asList("b", "c", "a");
      org.assertj.core.api.Assertions.assertThat(list)
          .containsExactlyInAnyOrderElementsOf(equalList);
    ```

    ```java
      public static void assertEquals(T expected, T actual, String message)
    ```

  - 一些好例子

    ```java
      final class Foo
      {
        // Members and other methods removed for brevity.

        public int bar(final int i)
        {
          if (shouldReturnDefaultValue(i))
          {
            logger.debug("Returning default value for: " + i);
            return DEFAULT_VALUE;
          }
          else
          {
            logger.debug("Returning calculated value for: " + i);
            return calculateValue(i);
          }
        }
      }
    ```

    ```java
      // Don't do this!
      public final class TestFoo
      {
        private FooDependency fooDependency = new FooDependency();

        // rest of test class removed for brevity
      }

      // Do this instead
      public final class TestFoo
      {
        private FooDependency fooDependency;

        @Before
        public void setUp()
        {
          fooDependency = new FooDependency();
        }
      }
    ```

    ```java
      final class Foo
      {
        int foo(int i) throws IOException;
      }
    ```

    ```java
      // Don't do this - it's not necessary to write the try/catch!
      @Test
      public void foo_seven()
      {
        try
        {
          assertEquals(3, new Foo().foo(7));
        }
        catch (final IOException e)
        {
          fail();
        }
      }

      // Do this instead
      @Test
      public void foo_seven() throws Exception
      {
        assertEquals(3, new Foo().foo(7));
      }
    ```

    ```java
      // Don't do this - it's not necessary to write the try/catch!
      @Test
      public void foo_nine()
      {
        boolean wasExceptionThrown = false;
        try
        {
          new Foo().foo(9);
        }
        catch (final IOException e)
        {
          wasExceptionThrown = true;
        }
        assertTrue(wasExceptionThrown);
      }

      // Do this instead
      @Test(expected = IOException.class)
      public void foo_nine() throws Exception
      {
        new Foo().foo(9);
      }
    ```

    ```java
      // Don't do this - it's not necessary to write the try/catch!
      @Test
      public void foo_seven()
      {
        try
        {
          assertEquals(3, new Foo().foo(7));
        }
        catch (final IOException e)
        {
          e.printStackTrace();
        }
      }

      // Do this instead
      @Test
      public void foo_seven() throws Exception
      {
        assertEquals(3, new Foo().foo(7));
      }
    ```

    ```java
      // Don't do this - the throws clause is too specific!
      @Test
      public void foo_seven() throws IOException
      {
        assertEquals(3, new Foo().foo(7));
      }

      // Don't do this - the throws clause is too specific!
      @Test
      public void foo_seven() throws IOException, GeneralSecurityException
      {
        assertEquals(3, new Foo().foo(7));
      }

      // Do this instead
      @Test
      public void foo_seven() throws Exception
      {
        assertEquals(3, new Foo().foo(7));
      }
    ```

## 11.5 贫血模型的传统开发模式
  实际上，你可能一直都在用贫血模型做开发，只是自己不知道而已。不夸张地讲，据我了解，目前几乎所有的业务后端系统，都是基于贫血模型的。我举一个简单的例子来给你解释一下。

  ```java
    ////////// Controller+VO(View Object) //////////
    public class UserController {
      private UserService userService; //通过构造函数或者IOC框架注入
      
      public UserVo getUserById(Long userId) {
        UserBo userBo = userService.getUserById(userId);
        UserVo userVo = [...convert userBo to userVo...];
        return userVo;
      }
    }

    public class UserVo {//省略其他属性、get/set/construct方法
      private Long id;
      private String name;
      private String cellphone;
    }

    ////////// Service+BO(Business Object) //////////
    public class UserService {
      private UserRepository userRepository; //通过构造函数或者IOC框架注入
      
      public UserBo getUserById(Long userId) {
        UserEntity userEntity = userRepository.getUserById(userId);
        UserBo userBo = [...convert userEntity to userBo...];
        return userBo;
      }
    }

    public class UserBo {//省略其他属性、get/set/construct方法
      private Long id;
      private String name;
      private String cellphone;
    }

    ////////// Repository+Entity //////////
    public class UserRepository {
      public UserEntity getUserById(Long userId) { //... }
    }

    public class UserEntity {//省略其他属性、get/set/construct方法
      private Long id;
      private String name;
      private String cellphone;
    }
  ```

## 11.6 充血模型的 DDD 开发模式
  ### 11.6.1 基于贫血模型的传统开发模式
  这是一个典型的 Web 后端项目的三层结构。其中，Controller 和 VO 负责暴露接口，具体的代码实现如下所示。注意，Controller 中，接口实现比较简单，主要就是调用 Service 的方法，所以，我省略了具体的代码实现。
  ```java
    public class VirtualWalletController {
      // 通过构造函数或者IOC框架注入
      private VirtualWalletService virtualWalletService;
      
      public BigDecimal getBalance(Long walletId) { ... } //查询余额
      public void debit(Long walletId, BigDecimal amount) { ... } //出账
      public void credit(Long walletId, BigDecimal amount) { ... } //入账
      public void transfer(Long fromWalletId, Long toWalletId, BigDecimal amount) { ...} //转账
      //省略查询transaction的接口
    }
  ```

  Service 和 BO 负责核心业务逻辑，Repository 和 Entity 负责数据存取。Repository 这一层的代码实现比较简单，不是我们讲解的重点，所以我也省略掉了。Service 层的代码如下所示。注意，这里我省略了一些不重要的校验代码，比如，对 amount 是否小于 0、钱包是否存在的校验等等。

  ```java       
    public class VirtualWalletBo {//省略getter/setter/constructor方法
      private Long id;
      private Long createTime;
      private BigDecimal balance;
    }

    public enum TransactionType {
      DEBIT,
      CREDIT,
      TRANSFER;
    }

    public class VirtualWalletService {
      // 通过构造函数或者IOC框架注入
      private VirtualWalletRepository walletRepo;
      private VirtualWalletTransactionRepository transactionRepo;
      
      public VirtualWalletBo getVirtualWallet(Long walletId) {
        VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);
        VirtualWalletBo walletBo = convert(walletEntity);
        return walletBo;
      }
      
      public BigDecimal getBalance(Long walletId) {
        return walletRepo.getBalance(walletId);
      }

      @Transactional
      public void debit(Long walletId, BigDecimal amount) {
        VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);
        BigDecimal balance = walletEntity.getBalance();
        if (balance.compareTo(amount) < 0) {
          throw new NoSufficientBalanceException(...);
        }
        VirtualWalletTransactionEntity transactionEntity = new VirtualWalletTransactionEntity();
        transactionEntity.setAmount(amount);
        transactionEntity.setCreateTime(System.currentTimeMillis());
        transactionEntity.setType(TransactionType.DEBIT);
        transactionEntity.setFromWalletId(walletId);
        transactionRepo.saveTransaction(transactionEntity);
        walletRepo.updateBalance(walletId, balance.subtract(amount));
      }

      @Transactional
      public void credit(Long walletId, BigDecimal amount) {
        VirtualWalletTransactionEntity transactionEntity = new VirtualWalletTransactionEntity();
        transactionEntity.setAmount(amount);
        transactionEntity.setCreateTime(System.currentTimeMillis());
        transactionEntity.setType(TransactionType.CREDIT);
        transactionEntity.setFromWalletId(walletId);
        transactionRepo.saveTransaction(transactionEntity);
        VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);
        BigDecimal balance = walletEntity.getBalance();
        walletRepo.updateBalance(walletId, balance.add(amount));
      }

      @Transactional
      public void transfer(Long fromWalletId, Long toWalletId, BigDecimal amount) {
        VirtualWalletTransactionEntity transactionEntity = new VirtualWalletTransactionEntity();
        transactionEntity.setAmount(amount);
        transactionEntity.setCreateTime(System.currentTimeMillis());
        transactionEntity.setType(TransactionType.TRANSFER);
        transactionEntity.setFromWalletId(fromWalletId);
        transactionEntity.setToWalletId(toWalletId);
        transactionRepo.saveTransaction(transactionEntity);
        debit(fromWalletId, amount);
        credit(toWalletId, amount);
      }
    }
  ```

### 11.6.2 基于充血模型的 DDD 开发模式

在这种开发模式下，我们把虚拟钱包 VirtualWallet 类设计成一个充血的 Domain 领域模型，并且将原来在 Service 类中的部分业务逻辑移动到 VirtualWallet 类中，让 Service 类的实现依赖 VirtualWallet 类。具体的代码实现如下所示：<br>

```java
  public class VirtualWallet { // Domain领域模型(充血模型)
    private Long id;
    private Long createTime = System.currentTimeMillis();;
    private BigDecimal balance = BigDecimal.ZERO;
    
    public VirtualWallet(Long preAllocatedId) {
      this.id = preAllocatedId;
    }
    
    public BigDecimal balance() {
      return this.balance;
    }
    
    public void debit(BigDecimal amount) {
      if (this.balance.compareTo(amount) < 0) {
        throw new InsufficientBalanceException(...);
      }
      this.balance = this.balance.subtract(amount);
    }
    
    public void credit(BigDecimal amount) {
      if (amount.compareTo(BigDecimal.ZERO) < 0) {
        throw new InvalidAmountException(...);
      }
      this.balance = this.balance.add(amount);
    }
  }

  public class VirtualWalletService {
    // 通过构造函数或者IOC框架注入
    private VirtualWalletRepository walletRepo;
    private VirtualWalletTransactionRepository transactionRepo;
    
    public VirtualWallet getVirtualWallet(Long walletId) {
      VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);
      VirtualWallet wallet = convert(walletEntity);
      return wallet;
    }
    
    public BigDecimal getBalance(Long walletId) {
      return walletRepo.getBalance(walletId);
    }
    
    @Transactional
    public void debit(Long walletId, BigDecimal amount) {
      VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);
      VirtualWallet wallet = convert(walletEntity);
      wallet.debit(amount);
      VirtualWalletTransactionEntity transactionEntity = new VirtualWalletTransactionEntity();
      transactionEntity.setAmount(amount);
      transactionEntity.setCreateTime(System.currentTimeMillis());
      transactionEntity.setType(TransactionType.DEBIT);
      transactionEntity.setFromWalletId(walletId);
      transactionRepo.saveTransaction(transactionEntity);
      walletRepo.updateBalance(walletId, wallet.balance());
    }
    
    @Transactional
    public void credit(Long walletId, BigDecimal amount) {
      VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);
      VirtualWallet wallet = convert(walletEntity);
      wallet.credit(amount);
      VirtualWalletTransactionEntity transactionEntity = new VirtualWalletTransactionEntity();
      transactionEntity.setAmount(amount);
      transactionEntity.setCreateTime(System.currentTimeMillis());
      transactionEntity.setType(TransactionType.CREDIT);
      transactionEntity.setFromWalletId(walletId);
      transactionRepo.saveTransaction(transactionEntity);
      walletRepo.updateBalance(walletId, wallet.balance());
    }

    @Transactional
    public void transfer(Long fromWalletId, Long toWalletId, BigDecimal amount) {
      //...跟基于贫血模型的传统开发模式的代码一样...
    }
  }
```

看了上面的代码，你可能会说，领域模型 VirtualWallet 类很单薄，包含的业务逻辑很简单。相对于原来的贫血模型的设计思路，这种充血模型的设计思路，貌似并没有太大优势。你说得没错！这也是大部分业务系统都使用基于贫血模型开发的原因。不过，如果虚拟钱包系统需要支持更复杂的业务逻辑，那充血模型的优势就显现出来了。比如，我们要支持透支一定额度和冻结部分余额的功能。这个时候，我们重新来看一下 VirtualWallet 类的实现代码。
```java
  public class VirtualWallet {
    private Long id;
    private Long createTime = System.currentTimeMillis();;
    private BigDecimal balance = BigDecimal.ZERO;
    private boolean isAllowedOverdraft = true;
    private BigDecimal overdraftAmount = BigDecimal.ZERO;
    private BigDecimal frozenAmount = BigDecimal.ZERO;
    
    public VirtualWallet(Long preAllocatedId) {
      this.id = preAllocatedId;
    }
    
    public void freeze(BigDecimal amount) { ... }
    public void unfreeze(BigDecimal amount) { ...}
    public void increaseOverdraftAmount(BigDecimal amount) { ... }
    public void decreaseOverdraftAmount(BigDecimal amount) { ... }
    public void closeOverdraft() { ... }
    public void openOverdraft() { ... }
    
    public BigDecimal balance() {
      return this.balance;
    }
    
    public BigDecimal getAvaliableBalance() {
      BigDecimal totalAvaliableBalance = this.balance.subtract(this.frozenAmount);
      if (isAllowedOverdraft) {
        totalAvaliableBalance += this.overdraftAmount;
      }
      return totalAvaliableBalance;
    }
    
    public void debit(BigDecimal amount) {
      BigDecimal totalAvaliableBalance = getAvaliableBalance();
      if (totoalAvaliableBalance.compareTo(amount) < 0) {
        throw new InsufficientBalanceException(...);
      }
      this.balance = this.balance.subtract(amount);
    }
    
    public void credit(BigDecimal amount) {
      if (amount.compareTo(BigDecimal.ZERO) < 0) {
        throw new InvalidAmountException(...);
      }
      this.balance = this.balance.add(amount);
    }
  }
```
领域模型 VirtualWallet 类添加了简单的冻结和透支逻辑之后，功能看起来就丰富了很多，代码也没那么单薄了。如果功能继续演进，我们可以增加更加细化的冻结策略、透支策略、支持钱包账号（VirtualWallet id 字段）自动生成的逻辑（不是通过构造函数经外部传入 ID，而是通过分布式 ID 生成算法来自动生成 ID）等等。VirtualWallet 类的业务逻辑会变得越来越复杂，也就很值得设计成充血模型了。



## 11.7 IoC容器和Dependency Injection模式

在这个例子中，我编写了一个组件，用于提供一份电影清单，清单上列出的影片都是由一位特定的导演执导的。实现这个伟大的功能只需要一个方法：
```java
  class MovieLister...

    public Movie[] moviesDirectedBy(String arg)
    {
        List allMovies = finder.findAll();
        for (Iterator it = allMovies.iterator(); it.hasNext();)
        {
            Movie movie = (Movie) it.next();
            if (!movie.getDirector().equals(arg))
            {
                it.remove();
            }

        }
        return (Movie[]) allMovies.toArray(new Movie[allMovies.size()]);
    }
```
你可以看到，这个功能的实现极其简单：moviesDirectedBy方法首先请求finder（影片搜寻者）对象（我们稍后会谈到这个对象）返回后者所知道的所有影片，然后遍历finder对象返回的清单，并返回其中由特定的某个导演执导的影片。非常简单，不过不必担心，这只是整个例子的脚手架罢了。我们真正想要考察的是finder对象，或者说，如何将MovieLister对象与特定的finder对象连接起来。为什么我们对这个问题特别感兴趣？因为我希望上面这个漂亮的moviesDirectedBy方法完全不依赖于影片的实际存储方式。所以，这个方法只能引用一个finder对象，而finder对象则必须知道如何对findAll 方法作出回应。为了帮助读者更清楚地理解，我给finder定义了一个接口：

```java
  public interface MovieFinder
  {
      List findAll();
  }
```

现在，两个对象之间没有什么耦合关系。但是，当我要实际寻找影片时，就必须涉及到MovieFinder的某个具体子类。在这里，我把涉及具体子类的代码放在MovieLister类的构造函数中。
```java
  class MovieLister...
    private MovieFinder finder;
    public MovieLister()
    {
        finder = new ColonDelimitedMovieFinder("movies1.txt");
    }
```

PicoContainer通过构造函数来判断如何将MovieFinder实例注入MovieLister 类。因此，MovieLister类必须声明一个构造函数，并在其中包含所有需要注入的元素：
```java
  class MovieLister...
    public MovieLister(MovieFinder finder)
    {
        this.finder = finder;
    }
```

MovieFinder实例本身也将由PicoContainer来管理，因此文本文件的名字也可以由容器注入：
```java
class ColonMovieFinder...
    public ColonMovieFinder(String filename)
    {
        this.filename = filename;
    }
```

随后，需要告诉PicoContainer：各个接口分别与哪个实现类关联、将哪个字符串注入MovieFinder组件。
```java
  private MutablePicoContainer configureContainer()
  {
      MutablePicoContainer pico = new DefaultPicoContainer();
      Parameter[] finderParams = {newConstantParameter("movies1.txt")};
      pico.registerComponentImplementation(MovieFinder.class,ColonMovieFinder.class, finderParams);
      pico.registerComponentImplementation(MovieLister.class);
      return pico;
  }
```
使用这个容器，你写出的代码大概会是这样：
```java
  public void testWithPico()
  {
      MutablePicoContainer pico = configureContainer();
      MovieLister lister = (MovieLister)pico.getComponentInstance(MovieLister.class);
      Movie[] movies = lister.moviesDirectedBy("Sergio Leone");
      assertEquals("Once Upon a Time in the West",movies[0].getTitle());
  }
```

Spring 框架是一个用途广泛的企业级Java 开发框架，其中包括了针对事务、持久化框架、web应用开发和JDBC等常用功能的抽象。和PicoContainer一样，它也同时支持构造函数注入和设值方法注入，但该项目的开发者更推荐使用设值方法注入——恰好适合这个例子。为了让MovieLister类接受注入，我需要为它定义一个设值方法，该方法接受类型为MovieFinder的参数：

```java
class MovieLister...
    private MovieFinder finder;
    public void setFinder(MovieFinder finder)
    {
        this.finder = finder;
    }
```

类似地，在MovieFinder的实现类中，我也定义了一个设值方法，接受类型为String 的参数：
```java
  class ColonMovieFinder...
    public void setFilename(String filename)
    {
        this.filename = filename;
    }
```

第三步是设定配置文件。Spring 支持多种配置方式，你可以通过XML 文件进行配置，也可以直接在代码中配置。不过，XML 文件是比较理想的配置方式。
```xml
  <beans>
    <bean id="MovieLister" class="spring.MovieLister">
        <property name="finder">
            <ref local="MovieFinder"/>
        </property>
    </bean>
    <bean id="MovieFinder" class="spring.ColonMovieFinder">
        <property name="filename">
            <value>movies1.txt</value>
        </property>
    </bean>
  </beans>
```
于是，测试代码大概就像下面这样：
```java
    public void testWithSpring() throws Exception
    {
        ApplicationContext ctx = newFileSystemXmlApplicationContext("spring.xml");
        MovieLister lister = (MovieLister) ctx.getBean("MovieLister");
        Movie[] movies = lister.moviesDirectedBy("Sergio Leone");
        assertEquals("Once Upon a Time in the West",movies[0].getTitle());
    }
```

除了前面两种注入技术，还可以在接口中定义需要注入的信息，并通过接口完成注入。Avalon框架就使用了类似的技术。在这里，我首先用简单的范例代码说明它的用法，后面还会有更深入的讨论。首先，我需要定义一个接口，组件的注入将通过这个接口进行。在本例中，这个接口的用途是将一个MovieFinder实例注入继承了该接口的对象。
```java
  public interface InjectFinder
  {
      void injectFinder(MovieFinder finder);
  }
```

这个接口应该由提供MovieFinder接口的人一并提供。任何想要使用MovieFinder实例的类（例如MovieLister类）都必须实现这个接口。
```java
  class MovieLister implements InjectFinder...
    public void injectFinder(MovieFinder finder)
    {
        this.finder = finder;
    }
```

然后，我使用类似的方法将文件名注入MovieFinder的实现类：
```java
  public interface InjectFilename
  {
      void injectFilename (String filename);
  }

  class ColonMovieFinder implements MovieFinder, InjectFilename...
      public void injectFilename(String filename)
      {
          this.filename = filename;
      }
```

现在，还需要用一些配置代码将所有的组件实现装配起来。简单起见，我直接在代码中完成配置，并将配置好的MovieLister 对象保存在名为lister的字段中：
```java
  class IfaceTester...
    private MovieLister lister;
    private void configureLister()
    {
        ColonMovieFinder finder = new ColonMovieFinder();
        finder.injectFilename("movies1.txt");
        lister = new MovieLister();
        lister.injectFinder(finder);
    }
```

测试代码则可以直接使用这个字段：
```java
  class IfaceTester...
    public void testIface()
    {
        configureLister();
        Movie[] movies = lister.moviesDirectedBy("Sergio Leone");
        assertEquals("Once Upon a Time in the West",movies[0].getTitle());
    }
```

在这里，我把ServiceLocator类实现为一个Singleton的注册表，于是MovieLister就可以在实例化时通过ServiceLocator获得一个MovieFinder实例。

```java
  class MovieLister...
    MovieFinder finder = ServiceLocator.movieFinder();

  class ServiceLocator...
      public static MovieFinder movieFinder()
      {
          return soleInstance.movieFinder;
      }
      private static ServiceLocator soleInstance;
      private MovieFinder movieFinder;
```

和注入的方式一样，我们也必须对服务定位器加以配置。在这里，我直接在代码中进行配置，但设计一种通过配置文件获得数据的机制也并非难事。
```java
  class Tester...
    private void configure()
    {
        ServiceLocator.load(new ServiceLocator(
        newColonMovieFinder("movies1.txt")));
    }

  class ServiceLocator...
      public static void load(ServiceLocator arg)
      {
          soleInstance = arg;
      }
      public ServiceLocator(MovieFinder movieFinder)
      {
      this.movieFinder = movieFinder;
      }
```

下面是测试代码：

```java
  class Tester...
    public void testSimple()
    {
        configure();
        MovieLister lister = new MovieLister();
        Movie[] movies = lister.moviesDirectedBy("Sergio Leone");
        assertEquals("Once Upon a Time in the West",movies[0].getTitle());

    }
```

此时，MovieLister 类的提供者也应该一并提供一个定位器接口，使用者可以通过这个接口获得MovieFinder实例。
```java
  public interface MovieFinderLocator
  {
    public MovieFinder movieFinder();
```

真实的服务定位器需要实现上述接口，提供访问MovieFinder实例的能力：
```java
    MovieFinderLocator locator = ServiceLocator.locator();
    MovieFinder finder = locator.movieFinder();
    public static ServiceLocator locator()
    {
      return soleInstance;
    }
    public MovieFinder movieFinder()
    {
        return movieFinder;
    }
    private static ServiceLocator soleInstance;
    private MovieFinder movieFinder;
```
在本例中，ServiceLocator使用一个map来保存服务信息，而不再是将这些信息保存在字段中。此外，ServiceLocator还提供了一个通用的方法，用于获取和加载服务对象。
```java
  class ServiceLocator...
    private static ServiceLocator soleInstance;
    public static void load(ServiceLocator arg)
    {
        soleInstance = arg;
    }
    private Map services = new HashMap();
    public static Object getService(String key)
    {
        return soleInstance.services.get(key);
    }
    public void loadService (String key, Object service)
    {
        services.put(key, service);
    }
```

同样需要对服务定位器进行配置，将服务对象与适当的关键字加载到定位器中：

```java
  class Tester...
    private void configure()
    {
        ServiceLocator locator = new ServiceLocator();
        locator.loadService("MovieFinder", newColonMovieFinder("movies1.txt"));
        ServiceLocator.load(locator);
    }
```

我使用与服务对象类名称相同的字符串作为服务对象的关键字：

```java
  class MovieLister...
    MovieFinder finder = (MovieFinder)
    ServiceLocator.getService("MovieFinder");
```

对于前面一直使用的例子，Berin Loritsch发送给了我一个简单的Avalon实现版本：
```java
  public class MyMovieLister implements MovieLister, Serviceable
  {
    private MovieFinder finder;
    public void service( ServiceManager manager )throws ServiceException
    {
        finder = (MovieFinder)manager.lookup("finder");
    }
```


