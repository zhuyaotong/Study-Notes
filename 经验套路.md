# 11. 经验套路

## 11.1 缓存更新的套路

  - Cache Aside Pattern

    这是最常用最常用的pattern了。其具体逻辑如下：
    - 失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。
    - 命中：应用程序从cache中取数据，取到后返回。
    - 更新：先把数据存到数据库中，成功后，再让缓存失效。

    
      <table>
        <tr>
          <td align="center" style="width: 800px;">
            <img src="https://coolshell.cn/wp-content/uploads/2016/07/Cache-Aside-Design-Pattern-Flow-Diagram-e1470471723210.png" style="width: 1142px;">
            <img src="https://coolshell.cn/wp-content/uploads/2016/07/Updating-Data-using-the-Cache-Aside-Pattern-Flow-Diagram-1-e1470471761402.png" style="width: 1142px;">
          </td>
        </tr>
      </table>

      注意，我们的更新是先更新数据库，成功后，让缓存失效。那么，这种方式是否可以没有文章前面提到过的那个问题呢？我们可以脑补一下。
      一个是查询操作，一个是更新操作的并发，首先，没有了删除cache数据的操作了，而是先更新了数据库中的数据，此时，缓存依然有效，所以，并发的查询操作拿的是没有更新的数据，但是，更新操作马上让缓存的失效了，后续的查询操作再把数据从数据库中拉出来。


## 11.2 XY问题

对于X-Y Problem的意思如下：

1）有人想解决问题X<br>
2）他觉得Y可能是解决X问题的方法<br>
3）但是他不知道Y应该怎么做<br>
4）于是他去问别人Y应该怎么做？

简而言之，没有去问怎么解决问题X，而是去问解决方案Y应该怎么去实现和操作。于是乎：

1）热心的人们帮助并告诉这个人Y应该怎么搞，但是大家都觉得Y这个方案有点怪异。<br>
2）在经过大量地讨论和浪费了大量的时间后，热心的人终于明白了原始的问题X是怎么一回事。<br>
3）于是大家都发现，Y根本就不是用来解决X的合适的方案。

X-Y Problem最大的严重的问题就是：在一个根本错误的方向上浪费他人大量的时间和精力！

## 11.3 如何问问题

  - 提问前先自己尝试查找答案，读读文档、手册，看看有没有相似的问题，看看那些方法能不能帮你解决问题，自己去试一试。如果你是程序员，你应该先学会自己调查一下源代码。（不然，人家回答你的一定是——RTFM – Read The Fucking Manual）这样的问题很多。我有时候很不愿意回答这样的问题，因为我觉得问问题的人把我当成了他的小跟班了。

  - 提问的时候，找正确的人或是正确的论坛发问。向陌生人或是不负责的人提问可能会是很危险的。不正确的人，会让你事倍功半。如果你问Linux的人Windows太慢怎么办？他们一定会让你把Windows删了装Linux去的。

  - 问的问题一定要是很明确的，并且阐述你做了哪些尝试，你一定要简化你的问题，这样可以让你的问题更容易被回答。对于一些问题，最好提供最小化的重现问题的步骤。
  
  - 你一定要让问题变得简单易读，这和写代码是一样的。只有简单易读的邮件，人们才会去读，试想看到一封巨大无比的邮件，读邮件的心情都没有了。而且，内容越多，可能越容易让人理解错了。

  - 你问问题的态度应该是以一种讨论的态度，即不是低三下四，也不是没有底气。只有这样，你和你的问题才能真正被人看得起。要达到这个状态，不想让别人看不起你，你就一定需要自己去做好充足的调查。问题 问得好的话，其实会让人觉得你很有经验的，能想到别人想不到的地方。

  - 不要过早下结论。比如：“我这边的程序不转了，我觉得是你那边的问题，你什么时候能fix？”，或是“太难调试了，gdb怎么这么烂？！”。当你这么做的时候，你一定要有足够的信息和证据，否则，你就显得很自大。好的问题应该是，“我和你的接口的程序有问题，我输入了这样的合法的参数，但是XX函数却总是返回失败，我们能一起看看吗？”，“我看了一下gdb的文档，发现我在用XXX命令调试YYY的时候，有这样ZZZ的问题，是不是我哪里做错了？”

## 11.4 单元测试

  - 一个死的单元测试

    ```C#
      public class Calculator
      {
          public int Add(int x, int y)
          {
              return x + y;
          }
      }

      class Program
      {
          static void Main(string[] args)
          {
              var calculator = new Calculator();

              int result = calculator.Add(5, 6);

              if (result != 11)
                  throw new InvalidOperationException();
          }
      }
    ```
  
  - 好的单元测试（用测试框架）

    ```C#
      [TestClass]
      public class UnitTest1
      {
          [TestMethod]
          public void TestMethod1()
          {
              var calculator = new Calculator();

              int result = calculator.Add(4, 3);

              Assert.AreEqual(7, result);
          }
      }

      [TestClass]
      public class CalculatorTests
      {
          [TestMethod]
          public void Adding_4_And_3_Should_Return_7()
          {
              var calculator = new Calculator();

              int result = calculator.Add(4, 3);

              Assert.AreEqual(7, result);
          }
      }
    ```

  - 针对异常情况的测试（JUnit）

    ```java
      @Test
      void testExpectedException() {
        ApplicationException thrown = Assertions.assertThrows(ApplicationException.class, () -> {
                //Code under test
        });
        Assertions.assertEquals("some message", exception.getMessage());
      }
    ```

  - 使用最合适的断言方法

    ```java
      List<String> list = Arrays.asList("a", "b", "c");
      List<String> equalList = Arrays.asList("b", "c", "a");
      org.assertj.core.api.Assertions.assertThat(list)
          .containsExactlyInAnyOrderElementsOf(equalList);
    ```

    ```java
      public static void assertEquals(T expected, T actual, String message)
    ```

  - 一些好例子

    ```java
      final class Foo
      {
        // Members and other methods removed for brevity.

        public int bar(final int i)
        {
          if (shouldReturnDefaultValue(i))
          {
            logger.debug("Returning default value for: " + i);
            return DEFAULT_VALUE;
          }
          else
          {
            logger.debug("Returning calculated value for: " + i);
            return calculateValue(i);
          }
        }
      }
    ```

    ```java
      // Don't do this!
      public final class TestFoo
      {
        private FooDependency fooDependency = new FooDependency();

        // rest of test class removed for brevity
      }

      // Do this instead
      public final class TestFoo
      {
        private FooDependency fooDependency;

        @Before
        public void setUp()
        {
          fooDependency = new FooDependency();
        }
      }
    ```

    ```java
      final class Foo
      {
        int foo(int i) throws IOException;
      }
    ```

    ```java
      // Don't do this - it's not necessary to write the try/catch!
      @Test
      public void foo_seven()
      {
        try
        {
          assertEquals(3, new Foo().foo(7));
        }
        catch (final IOException e)
        {
          fail();
        }
      }

      // Do this instead
      @Test
      public void foo_seven() throws Exception
      {
        assertEquals(3, new Foo().foo(7));
      }
    ```

    ```java
      // Don't do this - it's not necessary to write the try/catch!
      @Test
      public void foo_nine()
      {
        boolean wasExceptionThrown = false;
        try
        {
          new Foo().foo(9);
        }
        catch (final IOException e)
        {
          wasExceptionThrown = true;
        }
        assertTrue(wasExceptionThrown);
      }

      // Do this instead
      @Test(expected = IOException.class)
      public void foo_nine() throws Exception
      {
        new Foo().foo(9);
      }
    ```

    ```java
      // Don't do this - it's not necessary to write the try/catch!
      @Test
      public void foo_seven()
      {
        try
        {
          assertEquals(3, new Foo().foo(7));
        }
        catch (final IOException e)
        {
          e.printStackTrace();
        }
      }

      // Do this instead
      @Test
      public void foo_seven() throws Exception
      {
        assertEquals(3, new Foo().foo(7));
      }
    ```

    ```java
      // Don't do this - the throws clause is too specific!
      @Test
      public void foo_seven() throws IOException
      {
        assertEquals(3, new Foo().foo(7));
      }

      // Don't do this - the throws clause is too specific!
      @Test
      public void foo_seven() throws IOException, GeneralSecurityException
      {
        assertEquals(3, new Foo().foo(7));
      }

      // Do this instead
      @Test
      public void foo_seven() throws Exception
      {
        assertEquals(3, new Foo().foo(7));
      }
    ```
